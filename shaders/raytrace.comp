#version 450
#extension GL_GOOGLE_include_directive : enable

#include "octree.glsl"
#include "camera.glsl"
#include "ray.glsl"

#define STACK_SIZE 23
#define EPS 1.1920929e-7 // 2^(-23)

layout (binding = 0) buffer StorageBuffer {
    Octree octree;
};

layout(push_constant) uniform PushConstants {
    Camera camera;
};

layout (binding = 1, rgba8) uniform writeonly image2D raytrace_output_image;

layout (local_size_x = 16, local_size_y = 16) in;

struct StackItem {
	uint node;
	float t_max;
} stack[STACK_SIZE];

vec3 octree_raymarch_coarse(vec3 o, vec3 d) {
    // Octree resides at coordinates [8, 16] ([1, 2] * 8)
    float size = 8.0;
    float double_size = size * 2.0;
    float mid_point = (size + double_size) * 0.5;
    float mirror = size + double_size;

    // Get rid of small ray direction components to avoid division by zero
    d.x = abs(d.x) > EPS ? d.x : (d.x >= 0 ? EPS : -EPS);
	d.y = abs(d.y) > EPS ? d.y : (d.y >= 0 ? EPS : -EPS);
	d.z = abs(d.z) > EPS ? d.z : (d.z >= 0 ? EPS : -EPS);

    // Precompute the coefficients of tx(x), ty(y), and tz(z)
    vec3 t_coef = 1.0 / -abs(d);
	vec3 t_bias = t_coef * o;

    // Select octant mask to mirror the coordinate system so
    // that ray direction is negative along each axis.
    uint oct_mask = 0;

    if (d.x > 0.0)
		oct_mask ^= 1, t_bias.x = mirror * t_coef.x - t_bias.x;
	if (d.y > 0.0)
		oct_mask ^= 2, t_bias.y = mirror * t_coef.y - t_bias.y;
	if (d.z > 0.0)
		oct_mask ^= 4, t_bias.z = mirror * t_coef.z - t_bias.z;
    
    // Initialize the active span of t-values.
	float t_min = max(max(double_size * t_coef.x - t_bias.x, double_size * t_coef.y - t_bias.y), double_size * t_coef.z - t_bias.z);
	float t_max = min(min(size * t_coef.x - t_bias.x, size * t_coef.y - t_bias.y), size * t_coef.z - t_bias.z);
    // Negative t_min means we start inside the root I think
    t_min = max(t_min, 0.0);
    float h = t_max;

    // If the ray missed the root
    if (t_min > t_max)  
        return vec3(32.0, 32.0, 32.0);

    // Root is located at the last location in StorageBuffer
    uint parent = octree.descriptors[MEMORY_SIZE - 1];
    // Cached child descriptor
    uint descriptor = 0;
    vec3 pos = vec3(size);
    uint idx = 0;

    if (mid_point * t_coef.x - t_bias.x > t_min)
		idx ^= 1, pos.x = mid_point;
	if (mid_point * t_coef.y - t_bias.y > t_min)
		idx ^= 2, pos.y = mid_point;
	if (mid_point * t_coef.z - t_bias.z > t_min)
		idx ^= 4, pos.z = mid_point;

    uint scale = STACK_SIZE - 1;
    float scale_exp2 = 0.5 * size;

    while (scale < STACK_SIZE) {
        if (descriptor == 0)
            descriptor = octree.descriptors[((parent >> 8) + (idx ^ oct_mask))];

        // Determine maximum t-value of the cube by evaluating tx(), ty(), and tz() at its corner
        vec3 t_corner = pos * t_coef - t_bias;
        float tc_max = min(min(t_corner.x, t_corner.y), t_corner.z);

        if ((parent & 1 << (idx ^ oct_mask)) != 0 && t_min <= t_max) {
            // INTERSECT
            float tv_max = min(t_max, tc_max);
            float half_scale_exp2 = scale_exp2 * 0.5;
            // Intersect active t-span with the cube and evaluate tx(), ty(), and tz() at the center of the voxel
            vec3 t_center = half_scale_exp2 * t_coef + t_corner;

            if (t_min <= tv_max) {
                // If ray has hit a leaf child
                if (scale == 20) {
                    // Determine which side is hit
                    vec3 t_opp_corner = scale_exp2 * t_coef + t_corner;

                    if (t_opp_corner.y > t_opp_corner.x && t_opp_corner.y > t_opp_corner.z)
                        return vec3(43.0, 191.0, 191.0); // Darker blue for y-side
                    else if (t_opp_corner.x > t_opp_corner.z)
                        return vec3(36.0, 178.0, 178.0); // Even more darker blue x-side
                    else
                        return vec3(51.0, 255.0, 255.0); // Blue
                }

                // PUSH
                if (tc_max < h)
                    stack[scale] = StackItem(parent, t_max);

                h = tc_max;
                parent = descriptor;

                // Select child voxel that the ray enters first
                idx = 0;
                scale -= 1;
                scale_exp2 = half_scale_exp2;

                if (t_center.x > t_min)
    				idx ^= 1, pos.x += scale_exp2;
    			if (t_center.y > t_min)
    				idx ^= 2, pos.y += scale_exp2;
    			if (t_center.z > t_min)
    				idx ^= 4, pos.z += scale_exp2;

                descriptor = 0;
                t_max = tv_max;

                continue;
            }
        }

        // ADVANCE
        uint step_mask = 0;

		if (t_corner.x <= tc_max)
			step_mask ^= 1, pos.x -= scale_exp2;
		if (t_corner.y <= tc_max)
			step_mask ^= 2, pos.y -= scale_exp2;
		if (t_corner.z <= tc_max)
			step_mask ^= 4, pos.z -= scale_exp2;

        // Update active t-span and flip bits of the child slot index
        t_min = tc_max;
        idx ^= step_mask;

        // If the ray exists the octree without hitting a leaf voxel
        if (pos.x < 8.0 || pos.y < 8.0 || pos.z < 8.0)
            return vec3(96.0, 96.0, 96.0);

        // Proceed with pop if the bit flips disagree with the ray direction
        if ((idx & step_mask) != 0) {
            // POP
			// Find the highest differing bit between two positions
            uint differing_bits = 0;

			if ((step_mask & 1) != 0)
				differing_bits |= floatBitsToUint(pos.x) ^ floatBitsToUint(pos.x + scale_exp2);
			if ((step_mask & 2) != 0)
				differing_bits |= floatBitsToUint(pos.y) ^ floatBitsToUint(pos.y + scale_exp2);
			if ((step_mask & 4) != 0)
				differing_bits |= floatBitsToUint(pos.z) ^ floatBitsToUint(pos.z + scale_exp2);

            // Find MSB
            scale = findMSB(differing_bits);
            scale_exp2 = uintBitsToFloat((scale - STACK_SIZE + 127) << 23) * size; // exp2f(scale - s_max) * size

            // Restore parent voxel from the stack
            parent = stack[scale].node;
			t_max = stack[scale].t_max;

            // Round cube position and extract child slot index
            uint shx = floatBitsToUint(pos.x) >> scale;
			uint shy = floatBitsToUint(pos.y) >> scale;
			uint shz = floatBitsToUint(pos.z) >> scale;
			pos.x = uintBitsToFloat(shx << scale);
			pos.y = uintBitsToFloat(shy << scale);
			pos.z = uintBitsToFloat(shz << scale);

            idx = (shx & 1) | ((shy & 1) << 1) | ((shz & 1) << 2);

            // Prevent same parent from being stored again and invalidate cached child descriptor
            h = 0.0;
			descriptor = 0;
        } 
    }
    return vec3(32.0, 32.0, 32.0);
}


void main() {
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / imageSize(raytrace_output_image);
    Ray ray = create_ray(camera, uv.x, uv.y);

    vec3 color = octree_raymarch_coarse(ray.origin, ray.direction) / 255.0;
    
    imageStore(raytrace_output_image, ivec2(gl_GlobalInvocationID.xy), vec4(vec3(color.z, color.y, color.x), 0.0));
}