#version 450
#extension GL_GOOGLE_include_directive : enable

#define FLT_MAX 3.402823466e+38
#define MODEL_SIZE 4

struct Camera {
    vec3 origin;
    vec3 lower_left_corner;
    vec3 horizontal;
    vec3 vertical;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct BoundingBox {
    vec3 min_bound;
    vec3 max_bound;
};

struct Model {
    BoundingBox bounding_box;
    uint voxels[MODEL_SIZE * MODEL_SIZE * MODEL_SIZE];
};

layout (binding = 0) buffer SceneBuffer {
    Model model;
};

layout(push_constant) uniform PushConstants {
    Camera camera;
};

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 1, rgba8) uniform writeonly image2D raytrace_output_image;

Ray create_ray(float u, float v) {
    Ray ray = Ray(
        camera.origin, 
        //vec3(-0.7363797, 1.0, -0.41421357) + u * vec3(1.4727594, 0, 0) + (1.0 - v) * vec3(0.0, 0.0, 0.82842714) - vec3(0.0, 0.0, 0.0) // values read on CPU side of things
        camera.lower_left_corner + u * camera.horizontal + (1.0 - v) * camera.vertical - camera.origin
    );

    return ray;
}

vec3 ray_at(Ray ray, float t) {
    return ray.origin + (ray.direction * t);
}

uint location2index(vec3 location) {
    return uint(location.x  + location.y * MODEL_SIZE + location.z * MODEL_SIZE * MODEL_SIZE);
}

vec3 get_color(uint r, uint g, uint b) {
    // RGB_UINT to BGR_UNORM
    return vec3(b, g, r) / 255.0;
}

vec3 hit(Ray ray, float t_min, float t_max) {
    int face_index = 0;

    for(int i = 0; i < 3; ++i) {
        //vec3 min_bound = vec3(-2.0, 8.0, -2.0);
        //vec3 max_bound = min_bound + MODEL_SIZE;

        float temp0 = (model.bounding_box.min_bound[i] - ray.origin[i]) / ray.direction[i];
        float temp1 = (model.bounding_box.max_bound[i] - ray.origin[i]) / ray.direction[i];

        float t0 = 0;
        float t1 = 0;

        if (temp0 < temp1) {
            t0 = temp0;
            t1 = temp1;
        } else {
            t0 = temp1;
            t1 = temp0;
        }

        if (t_min < t0) {
            t_min = t0;
            face_index = i;
        }

        t_max = min(t1, t_max);

        if (t_max <= t_min) {
            // If the ray doesn't hit the box then the last vector component (face index) will be negative
            return vec3(0.0, 0.0, -1.0);
        }
    }

    return vec3(t_min, t_max, face_index);
}

vec3 traverse(Ray ray, vec3 hit) {
    vec3 ray_start = ray_at(ray, hit.x);
    vec3 ray_end = ray_at(ray, hit.y);

    // Even though components of these vectors are always integers I made them float vectors to avoid multiple type conversions
    vec3 current_location = vec3(0);
    vec3 end_location = vec3(0);

    for(int i = 0; i < 3; ++i) {
        current_location[i] = min(MODEL_SIZE, max(1.0, ceil(ray_start[i] - model.bounding_box.min_bound[i])));
        end_location[i] = min(MODEL_SIZE, max(1.0, ceil(ray_end[i] - model.bounding_box.min_bound[i])));
    }

    vec3 step = vec3(0);
    vec3 t_delta = vec3(0);
    vec3 t_max = vec3(0);

    float t_min = hit.x;

    for(int i = 0; i < 3; ++i) {
        if (ray.direction[i] > 0.0) {
            step[i] = 1.0;
            t_delta[i] = 1.0 / ray.direction[i];
            t_max[i] = t_min + (model.bounding_box.min_bound[i] + current_location[i] - ray_start[i]) / ray.direction[i];
        } else if (ray.direction[i] < 0.0) {
            step[i] = -1.0;
            t_delta[i] = 1.0 / -ray.direction[i];
            t_max[i] = t_min + (model.bounding_box.min_bound[i] + (current_location[i] - 1.0) - ray_start[i]) / ray.direction[i];
        } else {
            step[i] = 0.0;
            t_delta[i] = FLT_MAX;
            t_max[i] = FLT_MAX;
        }
    }

    float face_index = hit.z;

    vec3 voxel_color = get_color(153, 204, 255);
    vec3 background_color = get_color(38, 38, 38);

    while(true) {
        uint index = location2index(current_location - 1);

        if (model.voxels[index] != 0) {
            // different faces of a voxel have different brightness levels
            // the levels range from 0.8 to 1.0
            // if for example, face_index is 1 then the brightness is going to be 0.9 [(1 + 8) / 10 = 0.9]
            float brightness = (face_index + 8.0) / 10.0;
            
            return voxel_color * brightness;
        }

        if (current_location == end_location) {
            return background_color;
        }

        if (t_max.x < t_max.y && t_max.x < t_max.z) {
            // X-axis traversal.
            current_location.x = current_location.x + step.x;
            t_max.x = t_max.x + t_delta.x;
            face_index = 0.0;

        } else if (t_max.y < t_max.z) {
            // Y-axis traversal.
            current_location.y = current_location.y + step.y;
            t_max.y = t_max.y + t_delta.y;
            face_index = 1.0;

        } else {
            // Z-axis traversal.
            current_location.z = current_location.z + step.z;
            t_max.z = t_max.z + t_delta.z;
            face_index = 2.0;
        }
    }
}

#define STACK_SIZE 23
#define EPS 1.1920929e-7; // 2^(-23)

struct StackItem {
	uint node;
	float t_max;
} stack[STACK_SIZE];

vec3 octree_raymarch_coarse(vec3 o, vec3 d) {
    // Octree resides at coordinates [8, 16] ([1, 2] * 8)
    float size = 8.0;
    float double_size = size * 2.0;
    float mid_point = (size + double_size) * 0.5;
    
}

void main() {
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / imageSize(raytrace_output_image);
    Ray ray = create_ray(uv.x, uv.y);

    //vec3 unit_direction = normalize(ray.direction);
    //float t = 0.5 *(unit_direction.z + 1.0);
    //vec3 final_color = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(1.0, 0.7, 0.5); 

    vec3 final_color = vec3(0.0, 0.0, 0.0);

    float t_min = 0.0;
    float t_max = 100.0;

    // First check if the ray hits model's hitbox
    vec3 hit = hit(ray, t_min, t_max); 

    if (hit.z != -1) {
        //final_color = get_color(153, 204, 255);

        final_color = traverse(ray, hit);
    }
    

    imageStore(raytrace_output_image, ivec2(gl_GlobalInvocationID.xy), vec4(final_color, 0.0));
}